/* 
Copyright (C) 2022 Andreus Faria

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

using Ionic.Zlib;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace PrimalLauncher
{
    public class Packet
    {
        #region Properties
        public bool IsFromClient { get; private set; } //true when packet originates from client.
        public byte IsAuthenticated { get; private set; } = 0x01; //0x00: isAuthenticated;
        public byte IsCompressed { get; private set; } = 0x00; //0x01: isCompressed/encoded;
        public ushort ConnType { get; set; } //0x02: connectionType;
        public ushort Size { get; private set; } = 0x10; //0x04: packetSize;
        public ushort NumSubpackets { get; private set; } //0x06: numSubpackets;
        public uint TimeStamp { get; private set; } //0x08: timestamp; //Miliseconds
        public byte[] RawData { get; set; }       
        public Queue<SubPacket> SubPacketQueue { get; set; } = new Queue<SubPacket>();
        public List<SubPacket> SubPacketList { get; set; } = new List<SubPacket>();
        #endregion

        #region Constructors
        public Packet() { }
        public Packet(byte[] incoming) => PacketSetup(incoming);
        public Packet(SubPacket subPacket) => AddSubPacket(subPacket);       
        public Packet(GamePacket gamePacket) => AddSubPacket(new SubPacket(gamePacket));           
        public Packet(MessagePacket messagePacket) => AddSubPacket(new SubPacket(messagePacket));       
        #endregion

        public void AddSubPacket(SubPacket subPacket)
        {
            Size += subPacket.Size;
            SubPacketList.Add(subPacket);
        }

        public byte[] ToBytes(Blowfish blowfish = null)
        {
            byte[] result = new byte[Size];
            int index = 0x10;

            //header
            result.Write(new Dictionary<int, object>
            {
                {0, IsAuthenticated},
                {0x01, IsCompressed},
                {0x04, Size},
                {0x06, (byte)SubPacketList.Count},
                {0x08, Server.GetTimeStampHex()}               
            });     

            foreach (SubPacket sp in SubPacketList)
            {
                result.Write(index, sp.ToBytes(blowfish));                
                index += sp.Size;
            }

            if (Preferences.Instance.Options.PrintPacketsToFile)
                OutputToFile();

            return result;
        }

        public byte[] ToBytesZipped()
        {            
            byte[] packet = ToBytes();
            byte[] data = packet.GetSubset(0x10, packet.Length - 0x10);  
            byte[] zipped = Zip.Compress(data);                     
            byte[] result = new byte[zipped.Length + 0x10];

            result.Write(new Dictionary<int, object>
            {
                {0, packet.GetSubset(0, 0x10)}, //header
                {0x01, 0x01}, //is zipped flag
                {0x04, (ushort)zipped.Length},
                {0x10, zipped}
            });

            return result;
        }

        #region Dummy packets  
        public static byte[] AckPacket { get; } =
        {
            0x00, 0x00, 0x00, 0x00, 0xA0, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x90, 0x02, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0C, 0x69, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xED, 0x45, 0x02, 0x00, 0x00, 0x00, 0x00,
            0xC0, 0xED, 0xDF, 0xFF, 0xAF, 0xF7, 0xF7, 0xAF, 0x10, 0xEF, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF,
            0x42, 0x82, 0x63, 0x52, 0x01, 0x00, 0x00, 0x00, 0x10, 0xEF, 0xDF, 0xFF, 0x53, 0x61, 0x6D, 0x70,
            0x6C, 0x65, 0x20, 0x53, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x52, 0x75, 0x6E, 0x52, 0x75, 0x6E,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x02, 0x00, 0xF7, 0xAF, 0xAF, 0xF7, 0x00, 0x00, 0xB8, 0x6C, 0x4D, 0x02, 0x00, 0x00, 0x00, 0x00,
            0x10, 0x6C, 0x4D, 0x02, 0x00, 0x00, 0x00, 0x00, 0x40, 0x2C, 0xAC, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x4F, 0x62,
            0x6A, 0x65, 0x63, 0x74, 0x2E, 0x2E, 0x2E, 0x5B, 0x36, 0x36, 0x2E, 0x31, 0x33, 0x30, 0x2E, 0x39,
            0x39, 0x2E, 0x38, 0x32, 0x3A, 0x36, 0x33, 0x34, 0x30, 0x37, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x70, 0xEE, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF, 0x6C, 0x4E, 0x38, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x32, 0xEF, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF, 0xAF, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xC0, 0xEE, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF, 0xFE, 0x4E, 0x38, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x0B, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x20, 0xEF, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF,
            0x00, 0x01, 0xCC, 0xCC, 0x0C, 0x69, 0x00, 0xE0, 0xD0, 0x58, 0x33, 0x02, 0x00, 0x00, 0x00, 0x00,
            0x10, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x80, 0xEF, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF,
            0xC0, 0xEE, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF, 0xD0, 0xED, 0x45, 0x02, 0x00, 0x00, 0x00, 0x00,
            0xF0, 0xEE, 0xDF, 0xFF, 0xAF, 0xF7, 0xF7, 0xAF, 0x20, 0xEF, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF,
            0x0C, 0x69, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x6C, 0x4D, 0x02, 0x00, 0x00, 0x00, 0x00,
            0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x34, 0x30, 0x37, 0x00, 0x00, 0x00, 0x00,
            0x90, 0xEF, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF, 0x18, 0xBE, 0x34, 0x01, 0x00, 0x00, 0x00, 0x00,
            0xD8, 0x32, 0xAC, 0x01, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x32, 0xAC, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x02, 0x00, 0xF7, 0xAF, 0x42, 0x82, 0x63, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x36, 0x36, 0x2E, 0x31, 0x33, 0x30, 0x2E, 0x39, 0x39, 0x2E, 0x38, 0x32, 0x00, 0x00,
            0x00, 0x00, 0x36, 0x36, 0x2E, 0x31, 0x33, 0x30, 0x2E, 0x39, 0x39, 0x2E, 0x38, 0x32, 0x00, 0xFF,
            0x90, 0xEF, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF, 0x24, 0xCF, 0x76, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x10, 0x6C, 0x4D, 0x02, 0x00, 0x00, 0x00, 0x00, 0x70, 0x7A, 0xB7, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x6C, 0x4D, 0x02, 0x00, 0x00, 0x00, 0x00,
            0x90, 0xEF, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF, 0xD1, 0xF3, 0x37, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x10, 0x6C, 0x4D, 0x02, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x32, 0xAC, 0x01, 0x00, 0x00, 0x00, 0x00,
            0xC0, 0xEF, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF, 0xE8, 0x3E, 0x77, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x70, 0x99, 0xAA, 0x01, 0x0C, 0x69, 0x00, 0xE0, 0xA0, 0x32, 0xAC, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x58, 0x59, 0x33, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x6C, 0x4D, 0x02, 0x00, 0x00, 0x00, 0x00,
            0xE0, 0xEF, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF, 0x05, 0x3F, 0x77, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x0C, 0x69, 0x00, 0xE0, 0x0C, 0x69, 0x00, 0xE0, 0xA0, 0x32, 0xAC, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0xF0, 0xDF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFF, 0x23, 0x3F, 0x77, 0x01, 0x00, 0x00, 0x00, 0x00,
            0xC0, 0x5A, 0x33, 0x02, 0x0C, 0x69, 0x00, 0xE0, 0xA0, 0x32, 0xAC, 0x01, 0x00, 0x00, 0x00, 0x00,
        };      
        #endregion
                   
        private void PacketSetup(byte[] data)
        {
            if(data != null && data.Any(b => b != 0))
            {
                IsFromClient = true;
                IsAuthenticated = data[0x00];
                IsCompressed = data[0x01];
                ConnType = (ushort)(data[0x03] << 8 | data[0x02]);
                Size = (ushort)(data[0x05] << 8 | data[0x04]);
                NumSubpackets = (ushort)(data[0x07] << 8 | data[0x06]);
                //TimeStamp = (uint)(data[0x07] << 24 | data[0x07] << 16 | data[0x07] << 8 | data[0x06]);

                byte[] packetData = new byte[Size - 0x10];
                Buffer.BlockCopy(data, 0x10, packetData, 0, Size - 0x10);

                RawData = packetData;
            }
        }

        public void ProcessSubPackets(Blowfish bf)
        {            
            if(RawData != null)
            {
                int index = 0;
                ushort subPacketSize = (ushort)(RawData[0x01] << 8 | RawData[0]);

                for (int i = 1; i <= NumSubpackets; i++)
                {
                    try
                    {
                        byte[] subpacketData = new byte[subPacketSize - 0x10];

                        if (subpacketData.Length > 0x8) //do not process small sync packets
                        {
                            Buffer.BlockCopy(RawData, index + 0x10, subpacketData, 0, subpacketData.Length); //copy whole subpacket. + 0x10  = without subpacket header.            

                            SubPacket subpacket = new SubPacket
                            {
                                Size = subPacketSize,
                                Type = (ushort)(RawData[index + 0x03] << 8 | RawData[index + 0x02]),
                                SourceId = (uint)(RawData[index + 0x07] << 24 | RawData[index + 0x06] << 16 | RawData[index + 0x05] << 8 | RawData[index + 0x04]),
                                TargetId = (uint)(RawData[index + 0x0b] << 24 | RawData[index + 0x0a] << 16 | RawData[index + 0x09] << 8 | RawData[index + 0x08]),
                                Data = subpacketData
                            };

                            if (bf != null)
                                subpacket.Decrypt(bf);

                            SubPacketQueue.Enqueue(subpacket);
                        }

                        index += subPacketSize;

                        if (i < NumSubpackets)
                            subPacketSize = (ushort)(RawData[index + 0x01] << 8 | RawData[index + 0x00]);
                    }
                    catch (OverflowException) { break; }

                }
            }            
        } 
        
        public void Unzip()
        {
            byte[] result = ZlibStream.UncompressBuffer(RawData);
            RawData = result;
        }

        public static void Send(ServerOpcode opcode, byte[] data, uint sourceId = 0, uint targetId = 0)
        {
            try
            {
                GamePacket gamePacket = new GamePacket
                {
                    Opcode = (ushort)opcode,
                    Data = data
                };

                if (sourceId == 0 && User.Instance.Character != null)
                    sourceId = User.Instance.Character.Id;

                if (targetId == 0 && User.Instance.Character != null)
                    targetId = User.Instance.Character.Id;

                Packet packet = new Packet(new SubPacket(gamePacket) { SourceId = sourceId, TargetId = targetId });
                
                //TODO: for some reason the socket randomly comes null. It happens rarely, so shelving for later
                if(GameServer.Instance.Sender != null)
                    GameServer.Instance.Sender.Send(packet.ToBytes());

            }catch(Exception e)
            {
                GameServer.Instance.ClientIsConnected = false;
                Log.Instance.Error("Packet missed. Opcode: " + opcode.ToString() + ". Exception: " + e.Message);
            }          
        }

        public string Stringify()
        {           
            string result = "";

            if (IsFromClient)
            {
                foreach (SubPacket sp in SubPacketQueue)
                    result += sp.Stringify(IsFromClient);
            }
            else
            {
                foreach (SubPacket sp in SubPacketList)
                    result += sp.Stringify(IsFromClient);
            }            

            return result;
        }

        public void OutputToFile()
        {
            File.AppendAllText(Preferences.Instance.AppUserFolder + "packet_output.txt", Stringify());
        }
    }
}
