using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

namespace Launcher
{   
    [Serializable]
    public class Inventory
    {
        //The key in these dictionaries are the slot numbers. 
        public Dictionary<ushort, object> Bag = new Dictionary<ushort, object>();
        public Dictionary<ushort, object> Currency = new Dictionary<ushort, object>();
        public Dictionary<ushort, object> KeyItems = new Dictionary<ushort, object>();
        public Dictionary<ushort, object> Loot = new Dictionary<ushort, object>();
        public Dictionary<ushort, object> MeldRequest = new Dictionary<ushort, object>();
        public Dictionary<ushort, object> Bazaar = new Dictionary<ushort, object>();
        
        public Dictionary<ushort, ushort> GearSlots = new Dictionary<ushort, ushort>();
        
        public Inventory()
        {
            AddEmptySlots(ref Bag, InventoryMaxSlots.Bag);
            AddEmptySlots(ref Currency, InventoryMaxSlots.Currency);
            AddEmptySlots(ref KeyItems, InventoryMaxSlots.KeyItems);
            AddEmptySlots(ref Loot, InventoryMaxSlots.Loot);
            AddEmptySlots(ref MeldRequest, InventoryMaxSlots.MeldRequest);
            AddEmptySlots(ref Bazaar, InventoryMaxSlots.Bazaar);                      
        }

        #region Packet Handling
        private void ChunkStartPacket(Socket sender, InventoryMaxSlots maxSize, InventoryType type)
        {
            byte[] data = new byte[0x08];
            Buffer.BlockCopy(BitConverter.GetBytes(UserFactory.Instance.User.Character.Id), 0, data, 0, sizeof(uint));
            Buffer.BlockCopy(BitConverter.GetBytes((ushort)maxSize), 0, data, 0x04, sizeof(ushort));
            Buffer.BlockCopy(BitConverter.GetBytes((ushort)type), 0, data, 0x06, sizeof(ushort));
            SendPacket(sender, ServerOpcode.ChunkStart, data);
        }
        public void ChunkEndPacket(Socket sender) => SendPacket(sender, ServerOpcode.ChunkEnd, new byte[0x08]);
        public void InventoryStartPacket(Socket sender) => SendPacket(sender, ServerOpcode.InventoryStart, new byte[0x08]);
        public void InventoryEndPacket(Socket sender) => SendPacket(sender, ServerOpcode.InventoryEnd, new byte[0x08]);
        private void ChunkPacket(Socket sender, ServerOpcode opcode, byte[] data) => SendPacket(sender, opcode, data);

        /// <summary>
        /// Send an inventory packet.
        /// </summary>
        /// <param name="handler"></param>
        /// <param name="opcode"></param>
        /// <param name="data"></param>
        private void SendPacket(Socket handler, ServerOpcode opcode, byte[] data)
        {
            GamePacket gamePacket = new GamePacket
            {
                Opcode = (ushort)opcode,
                Data = data
            };

            Packet packet = new Packet(new SubPacket(gamePacket) { SourceId = UserFactory.Instance.User.Character.Id, TargetId = UserFactory.Instance.User.Character.Id });
            handler.Send(packet.ToBytes());
        }
        #endregion

        /// <summary>
        /// Initialize an inventory dict with all slots empty.
        /// </summary>
        /// <param name="inventory"></param>
        /// <param name="numSlots"></param>
        private void AddEmptySlots(ref Dictionary<ushort, object> inventory, InventoryMaxSlots numSlots)
        {
            for (int i = 0; i < (int)numSlots; i++)
                inventory.Add((ushort)i, null);
        }

        /// <summary>
        /// Returns the first empty slot in an inventory this is necessary to keep the continuity
        /// </summary>
        /// <param name="inventory"></param>
        /// <returns></returns>
        private ushort GetFirstEmptySlot(Dictionary<ushort, object> inventory)
        {
            foreach (var slot in inventory)
                if (slot.Value == null) return slot.Key;

            return 0; //inventory is full
        }

        /// <summary>
        /// Get item data from game data table, create item object and add to character bag. Used from chat window command.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="itemName"></param>
        /// <param name="quantity"></param>
        public void AddItem(ref Dictionary<ushort, object> inventory, string itemName, uint quantity, Socket sender = null)
        {
            DataTable itemNames = GameDataFile.Instance.GetGameData("xtx/itemName");
            DataRow[] selected = itemNames.Select("strc0 = '" + itemName + "'");

            if (selected.Length > 0)
            {
                uint itemId = (uint)selected[0][0];

                DataTable itemsData = GameDataFile.Instance.GetGameData("itemData");
                DataTable itemsStack = GameDataFile.Instance.GetGameData("_item");

                DataRow itemData = itemsData.Select("id = '" + itemId + "'")[0];
                DataRow itemStack = itemsStack.Select("id = '" + itemId + "'")[0];

                int itemMaxStack = (int)itemStack.ItemArray[2];
                int itemKind = (int)itemData.ItemArray[4];

                //if max stack is > 1, we change the quantity bytes to the quantity the user requested. 
                if (itemMaxStack > 1)
                {
                    //if the requested quantity is greater than the max stack, we limit it to the max stack.
                    uint itemQuantity = quantity > itemMaxStack ? (uint)itemMaxStack : quantity;
                    ushort slotToAddTo = GetFirstEmptySlot(inventory);

                    Item item = new Item
                    {
                        Id = itemId,
                        ItemKind = (uint)itemKind,
                        InventorySlot = slotToAddTo,
                        Quantity = itemQuantity,
                        MaxQuantity = (uint)itemMaxStack
                    };

                    inventory[slotToAddTo] = item;

                    if(sender!=null)
                        SendBagItem(sender, item.ToBytes());
                }
                else
                {
                    //calculate the amount of item units to add to the slot. Max is the number of available slots.
                    int numAvailableSlots = inventory.Select(x => x.Value == null).Count();
                    int itemTotalUnits = quantity > numAvailableSlots ? numAvailableSlots : (int)quantity;

                    //if item max stack is 1 (i.e. equipent), send the requested amount of the same item
                    for (int i = 0; i < itemTotalUnits; i++)
                    {
                        ushort slotToAddTo = GetFirstEmptySlot(inventory);
                        int durability = (int)itemData.ItemArray[1];

                        Item item = new Item
                        {
                            Id = itemId,
                            ItemKind = (uint)itemKind,
                            InventorySlot = slotToAddTo,
                            Durability = (uint)durability,
                            MaxDurability = (uint)durability
                        };

                        inventory[slotToAddTo] = item;

                        if (sender != null)
                            SendBagItem(sender, item.ToBytes());
                    }
                }
            }
        }

        /// <summary>
        /// Send packets from a single item added to inventory.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="data"></param>
        public void SendBagItem(Socket sender, byte[] data)
        {
            InventoryStartPacket(sender);
            ChunkStartPacket(sender, InventoryMaxSlots.Bag, InventoryType.Bag);
            ChunkPacket(sender, ServerOpcode.x01InventoryChunk, data);
            ChunkEndPacket(sender);
            InventoryEndPacket(sender);
        }

        /// <summary>
        /// Put all default items into character's bag. Used only during character creation.
        /// </summary>
        /// <param name="graphId">An arrray with selected class default equipment graphic codes from game data table boot_skillequip</param>
        public void AddDefaultItems(uint[] graphId)
        {
            //equipment
            AddEquipmentPiece(ItemGraphics.Weapon, graphId[1], 0);
            //AddDefaultItem(ItemGraphics.Weapon, graphId[2]); //leaving this on crashes the game. Seems that no class starts with a secondary weapon/tool. The value for archer/bard is for quiver graphics only.
            AddEquipmentPiece(ItemGraphics.Head, graphId[8], 8);
            AddEquipmentPiece(ItemGraphics.Body, graphId[9], 10);
            AddEquipmentPiece(ItemGraphics.Legs, graphId[10], 12);
            AddEquipmentPiece(ItemGraphics.Hands, graphId[11], 13);
            AddEquipmentPiece(ItemGraphics.Feet, graphId[12], 14);
            AddEquipmentPiece(ItemGraphics.Waist, graphId[13], 15);

            // giveaway on me =)
            AddItem(ref Bag, "Potion", 10);             
            AddItem(ref Currency, "Gil", 200);

           
        }

        #region Equipment Methods
        /// <summary>
        /// Adds one single default item into character's bag.
        /// </summary>
        /// <param name="equipList"></param>
        /// <param name="graphicId"></param>
        /// <param name="gearSlot"></param>
        private void AddEquipmentPiece(Dictionary<uint, uint> equipList, uint graphicId, ushort gearSlot)
        {            
            if (graphicId > 0)
            {            
                uint equipId = equipList.FirstOrDefault(x => x.Value == graphicId).Key;

                if (equipId > 0)
                {
                    ushort inventorySlot = AddEquipmentToBag(equipId);
                    AddEquipmentToGearSlot(gearSlot, inventorySlot);  
                }
            }
        }

        /// <summary>
        /// Equips an equipment piece to designated gear slot.
        /// </summary>
        /// <param name="gearSlot"></param>
        /// <param name="inventorySlot"></param>
        private void AddEquipmentToGearSlot(ushort gearSlot, ushort inventorySlot)
        {
            if(inventorySlot != 0xffff)            
                GearSlots[gearSlot] = inventorySlot;            
        }

        /// <summary>
        /// Adds equipment piece to character's bag.
        /// </summary>
        /// <param name="equipId"></param>
        /// <returns></returns>
        public ushort AddEquipmentToBag(uint equipId)
        {
            ushort slot = 0xffff;
            DataTable itemsData = GameDataFile.Instance.GetGameData("itemData");
            DataRow itemData = itemsData.Select("id = '" + equipId + "'")[0];
            
            int itemKind = (int)itemData.ItemArray[4];

            if (Bag.Select(x => x.Value == null).Count() > 0)
            {
                ushort slotToAddTo = GetFirstEmptySlot(Bag);
                int durability = (int)itemData.ItemArray[1];

                Item item = new Item
                {
                    Id = equipId,
                    ItemKind = (uint)itemKind,
                    InventorySlot = slotToAddTo,
                    Durability = (uint)durability,
                    MaxDurability = (uint)durability
                };

                Bag[slotToAddTo] = item;
                slot = slotToAddTo;
            }

            return slot;
        }

        /// <summary>
        /// Loads equipped gear pieces into their respective gear slots. Used at character spawn and inventory update.
        /// </summary>
        /// <param name="sender"></param>
        public void SendGearSlots(Socket sender)
        {
            int slotCount = GearSlots.Count;
            int index = 0;

            while(slotCount > 0)
            {
                if (slotCount >= 16)
                    slotCount = SendGearSlotChunk(sender, ServerOpcode.x16SetEquipment, 16, slotCount, ref index);
                else if (slotCount >= 8)
                    slotCount = SendGearSlotChunk(sender, ServerOpcode.x08SetEquipment, 8, slotCount, ref index);
                else if (slotCount < 8 && slotCount > 1)
                    slotCount = SendGearSlotChunk(sender, ServerOpcode.x08SetEquipment, 8, slotCount, ref index);
                else if (slotCount == 1)
                {
                    var slot = GearSlots.ElementAt(index);
                    EquipGear(sender, (byte)slot.Key, (byte)slot.Value);
                }
                    
            }  
        }

        /// <summary>
        /// Send one chunk of equipment slots. 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="opcode"></param>
        /// <param name="chunkSize"></param>
        /// <param name="numSlots"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private int SendGearSlotChunk(Socket sender, ServerOpcode opcode, int chunkSize, int numSlots, ref int index)
        {
            int numChunks = numSlots < chunkSize ? 1 : numSlots / chunkSize;
            int gearSlotSize = 0x06;

            //writes numChunks number of packets of chunkSize size.
            for (int i = 0; i < numChunks; i++)
            {
                using (MemoryStream data = new MemoryStream())
                {
                    //write slots
                    for (int j = 0; j < chunkSize; j++)
                    {
                        if ((index + j) > (GearSlots.Count - 1))
                        {
                            int zeroFillerSize = gearSlotSize * (chunkSize - numSlots); //how many empty slots we have to write
                            data.Write(new byte[zeroFillerSize], 0, zeroFillerSize);
                            break;
                        }
                        else
                        {
                            data.Write(BitConverter.GetBytes(GearSlots.ElementAt(index + j).Key), 0, sizeof(ushort));
                            data.Write(BitConverter.GetBytes(GearSlots.ElementAt(index + j).Value), 0, sizeof(ushort));
                            data.Write(BitConverter.GetBytes((ushort)0), 0, sizeof(ushort));
                        }
                            
                    }

                    if (chunkSize == 8)
                        data.Write(BitConverter.GetBytes((long)numSlots), 0, sizeof(long));

                    //send chunk
                    ChunkPacket(sender, opcode, data.ToArray());
                }
                index += chunkSize;
            }

            return numSlots < chunkSize ? 0 : numSlots - (chunkSize * numChunks);
        }
        
        /// <summary>
        /// Called from gear menu to swap gear in a gear slot.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="request"></param>
        public void SwitchGear(Socket sender, byte[] request)
        {
            //we read the bytes in the index below to be able to differentiate equip/unequip packets. It's the fastest way I can think of.
            uint pattern = (uint)(request[0x53] << 24 | request[0x52] << 16 | request[0x51] << 8 | request[0x50]);

            byte gearSlot = 0;
            byte invSlot = 0;
            uint itemUniqueId = 0;
            ServerOpcode opcode;

            if (pattern == 0x05050505)
            {
                gearSlot = (byte)(request[0x58] - 1);
                itemUniqueId = (uint)(request[0x5e] << 24 | request[0x5f] << 16 | request[0x60] << 8 | request[0x61]);
                opcode = ServerOpcode.x01SetEquipment;

                foreach (var slot in Bag)
                {
                    Item item = (Item)slot.Value;

                    if (item.UniqueId == itemUniqueId)
                    {
                        invSlot = (byte)item.InventorySlot;
                        UserFactory.Instance.User.Character.GearGraphics.Set(gearSlot, item.Id);

                        if (GearSlots.Any(x => x.Key == gearSlot))
                            GearSlots[gearSlot] = invSlot; //if there is anything in the slot, replace
                        else
                            GearSlots.Add(gearSlot, invSlot);

                        break;
                    }
                }
            }
            else
            {
                gearSlot = (byte)(request[0x51] - 1);
                GearSlots.Remove(gearSlot);
                UserFactory.Instance.User.Character.GearGraphics.Set(gearSlot, 0);
                opcode = ServerOpcode.x01RemoveEquipment;
            }

            InventoryStartPacket(sender);
            ChunkStartPacket(sender, InventoryMaxSlots.Equipment, InventoryType.Equipment);

            byte[] data = new byte[0x08];
            Buffer.BlockCopy(BitConverter.GetBytes(gearSlot), 0, data, 0, 1);
            Buffer.BlockCopy(BitConverter.GetBytes(invSlot), 0, data, 2, 1);

            SendPacket(sender, opcode, data);
            ChunkEndPacket(sender);
            InventoryEndPacket(sender);

            Update(sender);
            UserFactory.Instance.User.Character.SetAppearance(sender);
        }

        /// <summary>
        /// Used to unequip a piece of gear by passing the gear slot number. Part of chat window commands for test purpose.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="gearslot"></param>
        public void UnequipGear(Socket sender, byte gearslot)
        {
            InventoryStartPacket(sender);
            ChunkStartPacket(sender, InventoryMaxSlots.Equipment, InventoryType.Equipment);

            byte[] data = new byte[0x08];
            Buffer.BlockCopy(BitConverter.GetBytes(gearslot), 0, data, 0, 1);

            SendPacket(sender, ServerOpcode.x01RemoveEquipment, data);
            ChunkEndPacket(sender);
            InventoryEndPacket(sender);

            Update(sender);
        }

        /// <summary>
        /// Used to equip a piece of gear by passing the gear slot number and ite inventory item slot number. Part of chat window commands for test purpose.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="gearslot"></param>
        /// <param name="invSlot"></param>
        public void EquipGear(Socket sender, byte gearslot, byte invSlot)
        {
            InventoryStartPacket(sender);
            ChunkStartPacket(sender, InventoryMaxSlots.Equipment, InventoryType.Equipment);

            byte[] data = new byte[0x08];
            Buffer.BlockCopy(BitConverter.GetBytes(gearslot), 0, data, 0, 1);
            Buffer.BlockCopy(BitConverter.GetBytes(invSlot), 0, data, 2, 1);

            SendPacket(sender, ServerOpcode.x01SetEquipment, data);
            ChunkEndPacket(sender);
            InventoryEndPacket(sender);

            Update(sender);
        }
        #endregion

        /// <summary>
        /// Sends all inventories packets. Used when spawning player.
        /// </summary>
        /// <param name="sender"></param>
        public void SendPackets(Socket sender)
        {           
            InventoryStartPacket(sender);

            //Item bag
            ChunkStartPacket(sender, InventoryMaxSlots.Bag, InventoryType.Bag);
            SendItems(sender, Bag);
            ChunkEndPacket(sender);

            //Loot
            ChunkStartPacket(sender, InventoryMaxSlots.Loot, InventoryType.Loot);
            ChunkEndPacket(sender);

            //Meld Request
            ChunkStartPacket(sender, InventoryMaxSlots.MeldRequest, InventoryType.MeldRequest);
            ChunkEndPacket(sender);

            //Bazaar
            ChunkStartPacket(sender, InventoryMaxSlots.Bazaar, InventoryType.Bazaar);
            ChunkEndPacket(sender);

            //Currency/Crystals
            ChunkStartPacket(sender, InventoryMaxSlots.Currency, InventoryType.Currency);
            ChunkPacket(sender, ServerOpcode.x16InventoryChunk, new byte[]
            {
                //gil				                           | qty                  |
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x96, 0x14, 0x00, 0x41, 0x42, 0x0F, 0x00,
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //fire shard
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0xF9, 0x05, 0x00, 0x00, 0x43, 0x42, 0x0F, 0x00,
                0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //ice shard
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x05, 0x00, 0x00, 0x44, 0x42, 0x0F, 0x00,
                0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //wind shard
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x63, 0x06, 0x00, 0x00, 0x45, 0x42, 0x0F, 0x00,
                0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //earth shard
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x06, 0x00, 0x00, 0x46, 0x42, 0x0F, 0x00,
                0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //lightning shard
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x47, 0x42, 0x0F, 0x00,
                0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //water shard
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x68, 0x05, 0x00, 0x00, 0x48, 0x42, 0x0F, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //fire crystal
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x49, 0x42, 0x0F, 0x00,
                0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //ice crystal
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 0x4A, 0x42, 0x0F, 0x00,
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //wind crystal
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 0x4B, 0x42, 0x0F, 0x00,
                0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //earth crystal
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x00, 0x00, 0x00, 0x4C, 0x42, 0x0F, 0x00,
                0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //lightning crystal
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x4D, 0x42, 0x0F, 0x00,
                0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //water crystal
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00, 0x4E, 0x42, 0x0F, 0x00,
                0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //fire cluster
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x4F, 0x42, 0x0F, 0x00,
                0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //ice cluster
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x50, 0x42, 0x0F, 0x00,
                0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //wind cluster
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x51, 0x42, 0x0F, 0x00,
                0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            });
            ChunkPacket(sender, ServerOpcode.x08InventoryChunk, new byte[]
            {
                //earth cluster
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x52, 0x42, 0x0F, 0x00,
                0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //lightning cluster
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x53, 0x42, 0x0F, 0x00,
                0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //water cluster
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x54, 0x42, 0x0F, 0x00,
                0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //????
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x09, 0x43, 0x0F, 0x00,
                0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //serpent seals                                | quantity             |
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0xe8, 0x03, 0x00, 0x00, 0x0A, 0x43, 0x0F, 0x00,
                0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //???
                0xEF, 0x76, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14, 0x05, 0x00, 0x00, 0x0B, 0x43, 0x0F, 0x00,
                0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            });
            ChunkEndPacket(sender);

            //Key Items
            ChunkStartPacket(sender, InventoryMaxSlots.KeyItems, InventoryType.KeyItems);
            ChunkPacket(sender, ServerOpcode.x08InventoryChunk, new byte[]
            {
                0xA7, 0x76, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x49, 0x85, 0x1E, 0x00,
                0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                0xA7, 0x76, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x4A, 0x85, 0x1E, 0x00,
                0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                0xA7, 0x76, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x4D, 0x85, 0x1E, 0x00,
                0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                0xA7, 0x76, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x4E, 0x85, 0x1E, 0x00,
                0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                0xA7, 0x76, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x4F, 0x85, 0x1E, 0x00,
                0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                0xA7, 0x76, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6D, 0x88, 0x1E, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                0xA7, 0x76, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6F, 0x88, 0x1E, 0x00,
                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,


            });
            ChunkEndPacket(sender);

            InventoryEndPacket(sender);
        }

        /// <summary>
        /// Send packets to update character's inventory data.
        /// </summary>
        /// <param name="sender"></param>
        public void Update(Socket sender)
        {
            InventoryStartPacket(sender);
            //Item bag
            ChunkStartPacket(sender, InventoryMaxSlots.Bag, InventoryType.Bag);
            SendItems(sender, Bag);
            ChunkEndPacket(sender);

            ChunkStartPacket(sender, InventoryMaxSlots.Equipment, InventoryType.Equipment);
            SendGearSlots(sender);
            ChunkEndPacket(sender);

            InventoryEndPacket(sender);
        }


        /// <summary>
        ///  Used to send a test item to the loot list. Part of chat window commands for test purpose.
        /// </summary>
        /// <param name="handler"></param>
        public static void AddLoot(Socket handler)
        {

            //Inventory start
            handler.Send(new Packet(new GamePacket
            {
                Opcode = 0x16d,
                Data = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
            }).ToBytes());

            //Chunk start
            byte[] b = { 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x04, 0x00 };
            Buffer.BlockCopy(BitConverter.GetBytes(UserFactory.Instance.User.Character.Id), 0, b, 0, 4);
            handler.Send(new Packet(new GamePacket
            {
                Opcode = 0x146,
                Data = b
            }).ToBytes());

            //Chunk
            handler.Send(new Packet(new GamePacket
            {
                Opcode = 0x148,
                Data = new byte[] {
                    0x77, 0x52, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x7B, 0xBA, 0x98, 0x00,
                    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                }
            }).ToBytes());

            //Chunk end
            handler.Send(new Packet(new GamePacket
            {
                Opcode = 0x147,
                Data = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
            }).ToBytes());

            //Invenroty end
            handler.Send(new Packet(new GamePacket
            {
                Opcode = 0x16e,
                Data = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
            }).ToBytes());
        }
          
        /// <summary>
        /// Send packets containing all items in the specified inventory.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="inventory"></param>
        private void SendItems(Socket sender, Dictionary<ushort, object> inventory)
        {
            //get the number if items in the inventory
            List<Item> items = new List<Item>();
            foreach (var slot in inventory)
                if (slot.Value != null)
                    items.Add((Item)slot.Value); 

            int itemCount = items.Count;
            int index = 0;

            while (itemCount > 0)
            {
                if (itemCount >= 64)
                    itemCount = SendItemsChunk(sender, ServerOpcode.x64InventoryChunk, 64, itemCount, ref index, ref items);
                else if (itemCount >= 32)
                    itemCount = SendItemsChunk(sender, ServerOpcode.x32InventoryChunk, 32, itemCount, ref index, ref items);
                else if (itemCount >= 16)
                    itemCount = SendItemsChunk(sender, ServerOpcode.x16InventoryChunk, 16, itemCount, ref index, ref items);
                else if (itemCount >= 08)
                    itemCount = SendItemsChunk(sender, ServerOpcode.x08InventoryChunk, 08, itemCount, ref index, ref items);
                else if (itemCount < 08 && itemCount > 1)
                    itemCount = SendItemsChunk(sender, ServerOpcode.x08InventoryChunk, 08, itemCount, ref index, ref items);
                else if (itemCount == 01)
                {
                    SendBagItem(sender, items[index].ToBytes());
                    itemCount = 0;
                }
            }
        }

        /// <summary>
        /// Calculate how many chunk packets of the given size need to be sent and send them.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="opcode"></param>
        /// <param name="chunkSize"></param>
        /// <param name="numItems"></param>
        /// <param name="index"></param>
        /// <param name="itemList"></param>
        /// <returns></returns>
        private int SendItemsChunk(Socket sender, ServerOpcode opcode, int chunkSize, int numItems, ref int index, ref List<Item> itemList)
        {
            int numChunks = numItems < chunkSize ? 1 : numItems / chunkSize;
            int itemSlotSize = 0x70;

            //writes numChunks number of packets of chunkSize size.
            for (int i = 0; i < numChunks; i++)
            {
                using(MemoryStream data = new MemoryStream())
                {                   
                    //write items
                    for (int j = 0; j < chunkSize; j++)
                    {
                        if ((index + j) > (itemList.Count - 1))
                        {
                            int zeroFillerSize = itemSlotSize * (chunkSize - numItems); //how many empty slots we have to write
                            data.Write(new byte[zeroFillerSize], 0, zeroFillerSize);
                            break;
                        }                            
                        else
                            data.Write(itemList[index + j].ToBytes(), 0, itemSlotSize);    
                    }
                    
                    if(chunkSize == 8)
                        data.Write(BitConverter.GetBytes((long)numItems), 0, sizeof(long));

                    //send chunk
                    ChunkPacket(sender, opcode, data.ToArray());
                }
                index += chunkSize;
            }

            return numItems < chunkSize ? 0 : numItems - (chunkSize * numChunks);
        }
    }

    [Serializable]
    public class Item
    {
        public uint UniqueId { get; set; }
        public uint ItemKind { get; set; }
        public uint Id { get; set; }
        public ushort InventorySlot { get; set; }

        public uint Quantity { get; set; } = 1;
        public uint Durability { get; set; }

        public uint MaxQuantity { get; set; }
        public uint MaxDurability { get; set; }




        public uint Unknown1 { get; set; } //always 0

        public uint Category { get; set; }

        public ulong Unknown2 { get; set; } //only first byte has value
        public ulong Unknown3 { get; set; } //always 0

        public ulong Unknown4 { get; set; } //always 0
        public byte HQ { get; set; } //can be 1 or 2
        public byte Unknown5 { get; set; }
        public ushort Unknown6 { get; set; }
        public ushort Unknown7 { get; set; }
        public ushort Unknown8 { get; set; }

        public ulong Unknown9 { get; set; } //always 0
        public byte Unknown10 { get; set; } //can be 1 or 2
        public byte Unknown11 { get; set; } //can be 1 or 2
        public byte Unknown12 { get; set; } //can be 1 or 2
        public byte Unknown13 { get; set; } //can be 1 or 2
        public uint Unknown14 { get; set; } //always 0

        public Item()
        {
            UniqueId = NewId();
        }

        public uint NewId()
        {
            Random rnd = new Random();
            byte[] id = new byte[0x4];
            rnd.NextBytes(id);
            return BitConverter.ToUInt32(id, 0);
        }

        public byte[] ToBytes()
        {
            byte[] buffer = new byte[0x70];
            Buffer.BlockCopy(BitConverter.GetBytes(UniqueId), 0, buffer, 0, sizeof(uint));
            Buffer.BlockCopy(BitConverter.GetBytes(Quantity), 0, buffer, 0x08, sizeof(uint));
            Buffer.BlockCopy(BitConverter.GetBytes(Id), 0, buffer, 0x0c, sizeof(uint));
            Buffer.BlockCopy(BitConverter.GetBytes(InventorySlot), 0, buffer, 0x10, sizeof(ushort));
            Buffer.BlockCopy(BitConverter.GetBytes(Durability), 0, buffer, 0x2a, sizeof(uint));
            buffer[0x28] = 0x01;
            buffer[0x29] = 0x01;
            buffer[0x38] = 0x01;
            buffer[0x39] = 0x01;
            buffer[0x3a] = 0x01;
            buffer[0x3b] = 0x01;
            return buffer;
        }

        public Item Prepare(byte[] data)
        {
            Item item = new Item();

            return item;
        }
    }
}
